Ejemplo de juguete: 
    V= {brad pitt, angie j, snoop, guy fieri, tony, michael, vito, sonny, paulie, silvio}

    E={ {brad, angie}, {snoop, angie}, {tony, silvio}, {tony, paulie}, {tony, michael}, {tony, vito}, {vito, sonny}, {vito, michael}, {brad, tony}, {paulie, michael}, {vito, paulie}, {michael, paulie}, {michael, sonny}, {guy fieri, paulie}  }

    Influencias: 
    Tony = 10
    Vito = 10 
    Brad = 7
    Angie = 8
    Snoop = 9
    Guy fieri = 2
    Michael = 9
    Sonny = 7
    Paulie = 1
    Silvio = 5

    Q = {}
    K = {brad pitt, angie j, snoop, guy fieri, tony, michael, vito, sonny, paulie, silvio}
    K es el conjunto que tiene a todos los amigos de Brad (o del actor en el que estamos parados), entonces si agregamos a brad, dejamos solo los actores que sean sus amigos en K. (?)

    La idea del invariante es que no haya cliques que sean "islas", es decir que la clique quede totalmente aislada del resto de la red social. Por eso cada actor de K tiene un no amigo en K, ya que el actor en el que estamos parados tiene al menos un amigo de afuera de la clique. 

    Entra brad? si
    Q = {Brad}
    K = {angie, tony}

    Q = {Brad, angie}
    K = {}

Ordenamiento de Info: 


Idea: 

    Ordenariamos de menor a mayor ya que implica poder podar ramas del arbol antes de llegar al final. (asumiendo que agarramos siempre el elemento K[K.size()-1] para decidir si lo agregamos a Q o no) 

    1. ordenar V de menor a mayor por nivel de influencia. (antes de entrar a la funcion)

    2. Agregar K[1] a Q si es amigo de todos aquellos en Q (sol parcial). Una vez agregado, actualizar K para que contenga solo aquellos actores que sean amigos de todos los de Q. Llamar a la funcion con el actor agregado y luego quitarlo de Q. 

    3. Si K es vacio, fijarse si la suma de las influencias de los actores de Q supera a la suma maxima vista hasta el momento y en caso afirmativo, actualizarla. 

    Podas:
        - Fijarse antes de cada llamada a la funcion, si la suma de Q y los actores restantes de K no supera la suma maxima hasta ahora, entonces no hacer la llamada. (poda por optimalidad)

Algoritmo:

    Actor es un struct que contiene una funcion publica llamada influencia que toma como entrada un actor y me devuelve su poder de influencia. 

    V es el vector que contiene a todos los actores.

    E es el vector de tuplas que contiene a todas las amistades de la red social.

    Q y K son vectores de actores. 

    vector<actor> clique_con_mas_influencia(void){
        Ordenar vector V en orden creciente de influencia 
        if (hay alguien que es amigo de todos)
            lo meto en Q y lo saco de K asi conservo el invariante de K 
            llamo a clique con Q<mas popular>, K = V - <mas popular> 
        if (hay islas) 
            llamo a cada isla por separado y comparo el maximo entre todos y me quedo con el maximo de todos
        else 
            llamar a clique con Q=<>, K=V.
        devolver res
    }

    vector <actor> res

    void clique(Q,K){
        if(K es vacio){
            fijarse si la suma de las influencias de Q es mayor a la suma maxima, 
                actualizar suma maxima 
                res = Q
        }
        if(suma de Q + K actual <= suma maxima){return} else {
            if (K[1] es amigo de los de Q) {
                agrego K[1] a Q 
                actualizo K con sus amigos 
                llamo clique(Q', K')
                sacas K[1] de Q 
                actualizo K
                llamas clique(Q, K)
            } else {
                saco el primer elemento de K
                llamo clique(Q, K) 
            }
        }
    }


Incognitas:

    .Puedo llegar a una I donde tenga un elemento popular? 
        Q = ()

        K = (e0, e1, ..., en)

        Hay mas popular? Si! e0.  Mas popular: Es amigo de todos los actores de K antes de arrancar la funcion (ya que K = V)
        Popular: Es amigo de todos los actores de K pero en una Instancia posterior. 

        Q = (e0)

        K = (e1, ..., en)

    .Por que ese Invariante en K? 

    .Tener Islas rompe el Invariante en K? 
    
        1. Inv: (forall v, w in V)v in K => v es amigo de todos w in Q. 
        2. Inv: v in K, E un w no amigo de v en K. 

        Inv 1 y 2 => No puede haber islas. Porque? 
        Si v esta en K eso implica que es amigo de todos los w (por 1),  
        A su vez, v tiene al menos un no amigo en K. 

        Luego ese no amigo t tambien es amigo de los de Q. 







