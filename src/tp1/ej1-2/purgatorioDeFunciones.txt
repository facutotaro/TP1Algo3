agregarCliqueMasGrandeDeKAQ:
vector<Actor> cliqueActual;
    while (!grupo.empty()) {
        cliqueActual.push_back(masPopular(grupo)); // Me parece que el cliqueMasGrande no necesariamente contiene al masPopular.
        soloAmigosDeQEnK(cliqueActual, grupo);
    }
    return cliqueActual;
}

vector<Actor> cliqueMasGrande;
    vector<Actor> cliqueActual;
    int cliqueActualSize = 0;
    for(int r = 0; r < grupo.size(); r++){
        cliqueActual.push_back(grupo[r]);
        cliqueActualSize++;
        for(int j = 0; j < cliqueActualSize; j++){
            for(int k = 0; k < grupo.size(); k++){
                if(sonAmigos(cliqueActual[j], grupo[k])){
                    cliqueActual.push_back(grupo[k]);
                    cliqueActualSize++;
                }
            }
        }
        if (cliqueActual.size() > cliqueMasGrande.size()){
            cliqueMasGrande = cliqueActual;
        }
        while (0 < cliqueActual.size()){
            cliqueActual.pop_back();
        }
    }
    return cliqueMasGrande;


soloAmigosDeQEnK:
for(Actor u : K){
        bool esAmigoDeTodos = true;
        for(Actor v : Q){
            esAmigoDeTodos = esAmigoDeTodos && sonAmigos(v, u);
        }
        if (!esAmigoDeTodos){ // Sera eficiente?
            auto posicion = find(K.begin(), K.end(), u);
            K.erase(posicion);
        }
    }

Actor masPopular(vector<Actor> grupo) const;
Actor RedSocial::masPopular(vector<Actor> grupo) const { // No nos interesa el mas popular de ESE grupo?
    // No deberiamos preguntar si el elemento ademas de ser amigo del popular actual tambien esta en el grupo?
    int cantAmigosMax = 0;
    Actor popular(0, 0);

    for (int j = 0; j < grupo.size(); ++j) {
        int cantAmigos = 0;

        for(int k = 1; k < _matrizDeAmistades[j].size(); k++) {
            if( _matrizDeAmistades[j][k] && estaEnGrupo(k, grupo))
                cantAmigos++;
       }
        /*
        for (bool k: _matrizDeAmistades[j]) {
            cantAmigos += k;
        }
        */
        if (cantAmigos > cantAmigosMax) {
            cantAmigosMax = cantAmigos;
            popular = grupo[j];
        }
    }
    return popular;
}

bool estaEnGrupo(int id, const vector<Actor>& grupo) const;
bool RedSocial::estaEnGrupo(int id, const vector<Actor>& grupo) const {
    Actor temp(id, 0);
    return grupo.end() != find(grupo.begin(), grupo.end(), temp);
}

void RedSocial::agregarCliqueMasGrandeDeKAQ(vector<Actor>& Q, vector<Actor>& K) const{
    vector<Actor> noSonAmigosDeTodos;
    for(Actor v : K) { // O(|K|)
        if (esAmigoDeTodos(v, K)) { // O(|K|)
            Q.push_back(v);
        }  else {
            noSonAmigosDeTodos.push_back(v);
        }
    }
    K = noSonAmigosDeTodos;
}

void RedSocial::soloAmigosDeQEnK(vector<Actor>& Q, vector<Actor>& K) const{ //Cambiar ordenamiento de Actores y en vez de hacer erase usar pop back iterando sobre el ultimo.
    int j = K.size()-1;                                                     // O(K*Q) = O(n2)
    int contador = 0;
    while (j >= contador) {
        bool esAmigoDeTodos = true;
        for (Actor v : Q) { // O(|Q|)
            esAmigoDeTodos = esAmigoDeTodos && sonAmigos(v, K[j]);
        }
        if (esAmigoDeTodos) {
            Actor temp = K[contador];
            K[contador] = K[j];
            K[j] = temp;
            contador++;
        } else {
            K.pop_back();
            j--;
        }
    }
}

void RedSocial::agregarCliqueMasGrandeDeKAQ(vector<Actor>& Q, vector<Actor>& K, int& influenciaDeQ) const{ // O(k²)
    vector<Actor> ref = K; //O(k)
    for (int i = 0; i < K.size(); ++i) { //K * O(K) <- O(k²)
        if (esAmigoDeTodos(K[i], ref)){
            Q.push_back(K[i]);
            influenciaDeQ += K[i].influencia;
            K[i] = K[K.size()-1];
            K.pop_back();
        }
    }
}

bool RedSocial::esAmigoDeTodos(Actor a, const vector<Actor>& grupo) const { //O(grupo)
    bool esAmigoDeTodos = true;
    for(auto v : grupo){
        if (!(v == a) && !sonAmigos(a, v))
            esAmigoDeTodos = false;
            break;
    }
    return esAmigoDeTodos;
}

#include <assert.h>

void invariante(vector<Actor>& Q, vector<Actor>& K) const;

void RedSocial::invariante(vector<Actor>& Q, vector<Actor>& K) const{
    int type1 = 0; // LOS DEL CLIQUE NO SON AMIGOS: No se cumple Q.
    int type2 = 0; // LOS DEL CLIQUE NO SON AMIGOS CON LOS DE K: No se cumple Inv 1.
    int type3 = 0; // HAY POPULARES EN K: No se cumple Inv 2.
    for (auto & q : Q)
    {
        for (auto & k : K) // Hay no amigos en Q.
        {
            if (!(q == k) && !_matrizDeAmistades[q.id][k.id]) {
                type1++;

            }
        }
        for (auto & k : K) // Hay no amigos de los de Q en K.
        {
            if (!_matrizDeAmistades[q.id][k.id]) {
                type2++;
            }
        }
    }
    for (auto & k1 : K)
    {
        bool esPopular = true;
        for (auto & k2 : K) // Hay populares en K.
        {
            if (!(k1 == k2) && !_matrizDeAmistades[k1.id][k2.id]) {
                esPopular = false;
                break;
            }
        }
        if (esPopular) {
            type3++;

        }
    }
    for (int i = 0; i < K.size()-1; i++) {
        assert(K[i].influencia <= K[i+1].influencia);
    }
    type1 = type1 / 2;
    type2 = type2 / 2;
    type3 = type3 / 2;
    if (type1)cout << "LOS DEL CLIQUE NO SON AMIGOS(" << type1 << ")" << endl;
    if (type2)cout << "LOS DEL CLIQUE NO SON AMIGOS CON LOS DE K(" << type2 << ")" << endl;
    if (type3)cout << "HAY POPULARES EN K(" << type3 << ")" << endl;
}